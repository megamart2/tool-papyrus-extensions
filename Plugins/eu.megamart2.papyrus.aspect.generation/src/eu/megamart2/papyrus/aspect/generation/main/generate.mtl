[comment encoding = UTF-8 /]
[module generate('http://www.eclipse.org/uml2/5.0.0/UML')]

[import eu::megamart2::papyrus::aspect::generation::queries::aspectQueries/]

[template public generateAspect(aClass : Class) ? (aClass.isAspect())]
[comment @main/]
[comment Generation of aspect for each found class annotated as Aspect /]
[file (aClass.name.concat('.aj'), false, 'UTF-8')]
  [let s : Stereotype = aClass.getStereotype('aspectj::Aspect')]
    [if (aClass.getStereotypePropertyValue('aspectj::Aspect','isPrivileged').toString().contains('true'))]
privileged aspect [aClass.name/] {
    [else]
public aspect [aClass.name/] {
    [/if]
  [/let]
   
[comment Generation of poincuts for class properties annotated with one of stereotypes extending PointCut/]
[for(p : Property | aClass.getAllAttributes())]
	[comment Different cases for different types of pointcuts. Currently supported: CompositePointCut, CallPointCut, ArgsPointCut. To be completed /]
	[comment CompositePointCut/]
	[if (p.hasStereotype('aspectj::CompositePointCut'))]
	pointcut [p.name/]([let argsPointCut : Property = p.getArgsPointCut()][if (not argsPointCut.oclIsUndefined())][argsPointCut.fullSignature()/][/if][/let]):
		[comment For each pointcut aggregated by this composition/]
		[let list : OclAny = p.getStereotypePropertyValue('aspectj::CompositePointCut','composee')]
			[let last : OclAny = list->asSequence()->flatten()->last()]
				[for (composee : OclAny | list)]
					[comment Once obtained the stereotype slot composee (a Poincut stereotyped entity), we get the referenced entity by getting the base_PointCut_StructuralFeature value /]
					[let compProp : Property = composee.eGet('base_PointCut_StructuralFeature')]
						[comment We proceed for each composee pointcut depending on its type. Currently supported: CallPointCut, ArgsPointCut. To be completed /]
						[if (compProp.hasStereotype('aspectj::CallPointCut'))]
		call ([let signature : String = compProp.getStereotypePropertyValue('aspectj::CallPointCut', 'signature')][if (not signature.oclIsUndefined())][signature/] [/if][/let])
     					[/if]
						[if (compProp.hasStereotype('aspectj::ArgsPointCut'))]
     	args([compProp.noTypeSignature()/]);
     					[/if]
						[if (last <> composee)]
							[if (p.getStereotypePropertyValue('aspectj::CompositePointCut','type').oclAsType(EnumerationLiteral).name.equalsIgnoreCase('and'))]
		&&
							[/if]
						[/if]
					[/let]
				[/for]
			[/let]
		[/let]
     [/if]
	 [comment ArgsPointCut. This template is only applied if found pointcut is not part of a composition (managed above)/]
     [if (p.hasStereotype('aspectj::ArgsPointCut'))]
		[if (p.getStereotypePropertyValue('aspectj::ArgsPointCut','composite').oclIsUndefined())]
     		pointcut [p.name/] ():
     		args([let collection : OclAny = p.getStereotypePropertyValue('aspectj::ArgsPointCut','argNames')][collection/][/let]);
     	[/if]
     [/if]
	 [comment CallPointCut. This template is only applied if found pointcut is not part of a composition (managed above/]
     [if (p.hasStereotype('aspectj::CallPointCut'))]
		[if (p.getStereotypePropertyValue('aspectj::CallPointCut','composite').toString().equalsIgnoreCase(''))]
     		pointcut [p.name/](): call (
				[let signature : String = p.getStereotypePropertyValue('aspectj::CallPointCut', 'signature')]
					[if (not signature.oclIsUndefined())]
						[signature/] 
					[/if]
				[/let]
			);
		[/if]
     [/if]
   [/for]

[comment Generation of advices /]
  [for(o: Operation | aClass.getAllOperations())]
    [if (o.hasStereotype('aspectj::Advice'))]
		[let adviceExecution : EnumerationLiteral = o.getStereotypePropertyValue('aspectj::Advice', 'adviceExecution')]
	void [adviceExecution.name.toLower()/] ([let argsPointCut : Property = o.getArgsPointCut()][if (not argsPointCut.oclIsUndefined())][argsPointCut.fullSignature()/][/if][/let]):
			[let pointcut : OclAny = o.getStereotypePropertyValue('aspectj::Advice', 'pointcut')]
	 	[pointcut.eGet('base_PointCut_StructuralFeature').oclAsType(Property).name/]([let argsPointCut : Property = o.getArgsPointCut()][if (not argsPointCut.oclIsUndefined())][argsPointCut.noTypeSignature()/][/if][/let]){
					[o.method.eGet('body')/]
	}
			[/let]
		[/let]
    [/if]
  [/for]
}
[/file]
[/template] 

[comment  This template generates the complete fullSignature associated to a call ArgsPoinCut, which signature: parameter Type, .../]
[template public fullSignature(p : Property) post(trim())]
	[let argNames : Sequence(String) = p.getStereotypePropertyValue('aspectj::ArgsPointCut', 'argNames')->flatten()->asSequence()]
		[let types : Sequence(NamedElement) = p.getStereotypePropertyValue('aspectj::ArgsPointCut', 'type')->flatten()->asSequence()]
			[let indexes : Sequence(Integer) = argNames->collect(arg | argNames->indexOf(arg))]
				[let last : OclAny = argNames->last()]
					[for (index : Integer | indexes)][types->at(index).oclAsType(NamedElement).name/] [argNames->at(index)/][if (last <> argNames->at(index))],[/if][/for]
				[/let]
			[/let]
		[/let]
	[/let]
[/template]

[comment This template generates a parameter name signature for ArgsPointCut: parameter1, parameter2, ... /]
[template public noTypeSignature(p : Property) post(trim())]
	[let collection : OclAny = p.getStereotypePropertyValue('aspectj::ArgsPointCut','argNames')]
		[let last : OclAny = collection->asSequence()->flatten()->last()]
			[for (argName : String | collection)][argName/][if (last <> argName)],[/if][/for]
		[/let]
	[/let]
[/template]
